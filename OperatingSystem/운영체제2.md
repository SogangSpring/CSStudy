## CPU 스케줄링

### 정의
cpu 스케줄링이란 cpu스케줄러가 어떤 프로세스에 CPU를 배정할지 결정하는 작업을 의미한다.
- 조건 : 오버헤드 ↓ / 사용률 ↑ / 기아 현상 ↓
- 목표
    1. Batch System: 가능하면 많은 일을 수행. 시간(time) 보단 처리량(throughout)이 중요
    2. Interactive System: 빠른 응답 시간. 적은 대기 시간.
    3. Real-time System: 기한(deadline) 맞추기.

### CPU 스케줄링의 종류.
CPU스케줄링은 보통 선점 스케줄링과, 비선점 스케줄링으로 나누어 설명합니다.

### 선점/ 비선점 스케줄링
- 선점: 시분할 시스템에서 타임 슬라이스가 소진되었거나, 인터럽트나 시스템 호출 종료 시에 더 높은 우선 순위 프로세스가 발생 되었음을 알았을 때, 현 실행 프로세스로부터 강제로 CPU를 회수하는 것
-> 우선순위가 높으면 CPU를 중간에 뺏어서 할당받을 수 있음.

- 비선점: 프로세스가 자원을 할당 받았을 경우, 자원을 스스로 반납할 때까지 계속 그 자원을 사용하도록 허용하는 정책
-> 문제가 생기지 않는 이상 작업 종료 전까지 CPU 사용 가능.
 
**비선점 스케줄링**
• FCFS : 큐에 도착한 순서대로 CPU 할당
• SJF : 수행시간이 짧은 것 부터 CPU 할당
• HRN : 우선순위 = (대기시간 + 실행시간)/(실행시간)으로 계산해서 우선순위 책정 및 CPU 할당.

**선점 스케줄링**
• 우선순위 스케줄링 : 우선순위가 높은 순서대로 처리, 아래의 스케줄링 방식은 모두 일종의 우선순위 스케줄링이다.
• Round Robin : 동일한 시간의 time quantum만큼 할당
• Multilevel Queue : 작업을 여러 종류의 큐로 나누어 큐마다 다른 time quantum 할당
• Multilevel-feedback Queue : Multilevel에서 time quantum을 채우면 다음 level로 내려감, 현대 운영체제에서 주로 채택됨.

### 기아상태
- 프로세스가 끊임없이 필요한 컴퓨터 자원을 가져오지 못하는 상황

#### 해결 방안
 - 우선순위 변경 : 프로세스 우선순위를 수시로 변경해서, 각 프로세스가 높은 우선순위를 가질 기회주기 EX) Queure를 활용한 기법.
 - Aging: 오래 기다린 프로세스의 우선순위를 높여주기
 - 우선순위가 아닌, 요청 순서대로 처리하는 FIFO 기반 요청큐 사용

## 데드락(교착상태)

### 교착상태?
교착 상태란 두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태를 말합니다.

### 교착상태 발생조건

교착 상태(데드락)은 비선점, 환형대기, 점유와대기,  상호배제의 조건이 모두 충족될 경우에 발생합니다.

1. **상호 배제(Mutual exclusion)**
자원은 한번에 한 프로세스만 사용할 수 있음

2. **점유 대기(Hold and wait)**
최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 함

3. **비선점(No preemption)**
다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음

4. **순환 대기(Circular wait)**
프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 함

### 교착상태 해결책

1. **예방(prevention)**
    
    교착 상태 발생 조건 중 하나를 제거하면서 해결한다 (자원 낭비 엄청 심함)
    
    - 상호배제 부정 : 여러 프로세스가 공유 자원 사용
    - 점유대기 부정 : 프로세스 실행전 모든 자원을 할당
    - 비선점 부정 : 자원 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원 반납
    - 순환대기 부정 : 자원에 고유번호 할당 후 순서대로 자원 요구

2. **회피(avoidance) -** 교착 상태 발생 시 피해나가는 방법
    
    **은행원 알고리즘(Banker's Algorithm)**
    
    은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래함
    
    프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있으면 자원할당, 아니면 할당을 거부하고 다른 프로세스 들이 자원을 해지할때까지 대기하는 방법
    
3. **탐지(Detection) & 회복**
    
    - 은행원 알고리즘과 유사한 방식 vs 자원 할당 그래프를 통해 교착 상태를 탐지함
    
    - 자원 요청 시, 탐지 알고리즘을 실행시켜 그에 대한 오버헤드 발생함
    
    - 타임아웃을 이용한 교착상태의 검출 : 현대 운영체제와 DB에서 사용되는 방법

4. **회복(Recovery) -** 교착 상태 일으킨 프로세스를 종료하거나, 할당된 자원을 해제시켜 회복시키는 방법
    
    **프로세스 종료 방법**
    
    - 교착 상태의 프로세스를 모두 중지
    - 교착 상태가 제거될 때까지 하나씩 프로세스 중지
    
    **자원 선점 방법**
    
    - 교착 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에게 할당 (해당 프로세스 일시정지 시킴)
    - 우선 순위가 낮은 프로세스나 수행 횟수 적은 프로세스 위주로 프로세스 자원 선점

5. **무시**

교착상태가 자주 일어나는 상황이 아니기 때문에, 현대 운영체제에서는 대부분 교착상태가 발생할 경우에, 사용자 스스로 처리할 수 있도록 에러를 띄우는 교착상태 무시 방법을 사용합니다.

## Race Condition

경쟁상태는 **동시성 문제**와 관련되어 있습니다.

### 정의
```
두 개 이상의 프로세스가 공통 자원을 병행적으로(concurrently) 읽거나 쓰는 동작을 할 때, 공용 데이터에 대한 접근이 어떤 순서에 따라 이루어졌는지에 따라 그 실행 결과가  달라지는 상황
```

### Race Condition이 발생하는 경우

1. 커널 작업을 수행하는 중에 인터럽트 발생
    - 문제점 : 커널모드에서 데이터를 로드하여 작업을 수행하다가 인터럽트가 발생하여 같은 데이터를 조작하는 경우
    - 해결법 : 커널모드에서 작업을 수행하는 동안, 인터럽트를 disable 시켜 CPU 제어권을 가져가지 못하도록 한다.

2. 프로세스가 'System Call'을 하여 커널 모드로 진입하여 작업을 수행하는 도중 문맥 교환이 발생할 때
    - 문제점 : 프로세스1이 커널모드에서 데이터를 조작하는 도중, 시간이 초과되어 CPU 제어권이 프로세스2로 넘어가 같은 데이터를 조작하는 경우 ( 프로세스2가 작업에 반영되지 않음 )
    - 해결법 : 프로세스가 커널모드에서 작업을 하는 경우 시간이 초과되어도 CPU 제어권이 다른 프로세스에게 넘어가지 않도록 함

3. 멀티 프로세서 환경에서 공유 메모리 내의 커널 데이터에 접근할 때
    - 문제점 : 멀티 프로세서 환경에서 2개의 CPU가 동시에 커널 내부의 공유 데이터에 접근하여 조작하는 경우
    - 해결법 : 커널 내부에 있는 각 공유 데이터에 접근할 때마다, 그 데이터에 대한 lock/unlock을 하는 방법


## 세마포어(Semaphore) & 뮤텍스(Mutex)

공유된 자원에 여러 프로세스가 동시에 접근하면서 문제가 발생할 수 있다. 이때 공유된 자원의 데이터는 한 번에 하나의 프로세스만 접근할 수 있도록 제한을 둬야 한다.

세마포어와 뮤텍스는 모두 동기화 문제를 해결하기 위한 방법입니다.

여러 프로세스가 공유자원에 접근할때, 한 프로세스가 임계영역에서 수행중이라면 다른 프로세스는 자신의 크리티컬 섹션에 들어가지 못하게 해야합니다

**세마포어**에는 P연산과 V연산이 있습니다. P연산은 자원을 할당하는 연산이고 V연산은 자원을 해제하는 연산입니다. 크리티컬 섹션에 들어가기 전 세마포어를 통해 자원에 접근가능한지 확인을 하며 동기화문제를 해결합니다. 공유 자원에 프로세스들이 최대 허용치만큼 접근할 수 있음

**뮤텍스**는 이진 세마포어의 일종으로 자원에 lock을 걸면서 동기화 문제를 해결합니다. **상호 배제** 개념을 이용하며 크리티컬 섹션을 가진 스레드들이 각각 단독으로 실행되게 하는 기술입니다.



## 페이징 & 세그먼테이션

### 메모리 관리 기법

1. 연속 메모리 관리
프로그램 전체가 하나의 커다란 공간에 연속적으로 할당되어야 함

고정 분할 기법 : 주기억장치가 고정된 파티션으로 분할 (내부 단편화 발생)
동적 분할 기법 : 파티션들이 동적 생성되며 자신의 크기와 같은 파티션에 적재 (외부 단편화 발생)


2. 불연속 메모리 관리
프로그램의 일부가 서로 다른 주소 공간에 할당될 수 있는 기법

페이지 : 고정 사이즈의 작은 프로세스 조각

프레임 : 페이지 크기와 같은 주기억장치 메모리 조각

단편화 : 기억 장치의 빈 공간 or 자료가 여러 조각으로 나뉘는 현상

세그먼트 : 서로 다른 크기를 가진 논리적 블록이 연속적 공간에 배치되는 것


- 단순 페이징
    - 각 프로세스는 프레임들과 같은 길이를 가진 균등 페이지로 나뉨

    - 외부 단편화 X

    - 소량의 내부 단편화 존재


- 단순 세그먼테이션
    - 각 프로세스는 여러 세그먼트들로 나뉨

    - 내부 단편화 X, 메모리 사용 효율 개선, 동적 분할을 통한 오버헤드 감소

    - 외부 단편화 존재


- 가상 메모리 페이징
    - 단순 페이징과 비교해 프로세스 페이지 전부를 로드시킬 필요X

    - 필요한 페이지가 있으면 나중에 자동으로 불러들어짐

    - 외부 단편화 X

    - 복잡한 메모리 관리로 오버헤드 발생


- 가상 메모리 세그먼테이션
    - 필요하지 않은 세그먼트들은 로드되지 않음

    - 필요한 세그먼트 있을때 나중에 자동으로 불러들어짐

    - 내부 단편화X

    - 복잡한 메모리 관리로 오버헤드 발생

**메모리 관리 기법**

- 연속 메모리 관리 : 고정 분할(내부단편화), 동적 분할(외부단편화)
- 불연속 메모리 관리 : 페이징, 세그멘테이션

## 페이지 교체 알고리즘

페이지 부재 발생 → 새로운 페이지를 할당해야 함 → 현재 할당된 페이지 중 어떤 것 교체할 지 결정하는 방법이다.

FIFO 알고리즘: 제일 먼저 들어간 것 먼저 나오게

LRU 알고리즘 : 최근에 가장 적게 사용된 페이지를 나오게

OPT 알고리즘 : 앞으로 가장 사용하지 않을 페이지 교체

[https://doh-an.tistory.com/28](https://doh-an.tistory.com/28)

## 메모리(Memory)

### 메인 메모리

### 캐시 메모리
주기억장치에 저장된 내용의 일부를 임시로 저장해두는 기억장치
CPU와 주기억장치의 속도 차이로 성능 저하를 방지하기 위한 방법

### 물리 메모리

### 가상 메모리
가상 메모리는 물리 메모리의 크기와 관계없이 메모리를 사용할 수 있도록 지원하는 기술이다.

현대 메모리 관리에서는 이러한 가상 메모리를 통해 물리 메모리의 크기와 프로세스가 올라갈 메모리의 위치를 신경쓰지않고 프로그래밍하도록 지원한다.

장점: 물리적 메모리에 제약을 받지 않는다. 병행성 및 cpu 이용률이 올라간다

단점: 전반적인 속도 저하가 있다.

## 파일 시스템

### 파일
 컴퓨터 등의 기기에서 의미 있는 정보를 담는 논리적인 단위

### 파일 시스템
컴퓨터에서 파일이나 자료를 쉽게 발견할 수 있도록, 유지 및 관리하는 방법이다.
저장매체에는 수많은 파일이 있기 때문에, 이런 파일들을 관리하는 방법을 말한다

### 특징
- 커널 영역에서 동작
- 파일 CRUD 기능을 원활히 수행하기 위한 목적
- 계층적 디렉터리 구조를 가짐
- 디스크 파티션 별로 하나씩 둘 수 있음


### 역할
- 파일 관리
- 보조 저장소 관리
- 파일 무결성 메커니즘
- 접근 방법 제공

### 개발 목적
- 하드디스크와 메인 메모리 속도차를 줄이기 위함
- 파일 관리
- 하드디스크 용량 효율적 이용

### 구조
- 메타 영역 : 데이터 영역에 기록된 파일의 이름, 위치, 크기, 시간정보, 삭제유무 등의 파일 정보
- 데이터 영역 : 파일의 데이터