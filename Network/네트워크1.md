# OSI 7 계층

* 계층을 나눈 이유는 통신이 일어나는 과정이 단계별로 쉽게 파악할 수 있기 때문이며, 특정한 곳에 이상이 생기면 이상이 생긴 단계만 고칠 수 있기 때문이다.
* 예를 들어, PC방에서 게임을 하다가 연결이 끊어졌을 경우
  * 모든 PC에 문제가 있다면, 네트워크 계층인 라우터를 살펴보거나 광랜을 제공하는 회사의 회선(물리계층)에 문제가 생긴 것으로 추측할 수 있다.
  * 한 PC에만 문제가 있다면, 게임 소프트웨어의 문제(어플리케이션 계층)이거나 스위치(데이터링크 계층)에 문제가 있다고 추측할 수 있다.

1. 물리계층 : 1계층

   * 전기적, 기계적 특성을 이용해 통신케이블로 데이터를 전송한다.

   * 이 계층에서 사용하는 통신계층은 비트이며 1,0이고 전기적으로 On, Off 상태라고 생각하면 된다.

   * 이 계층은 데이터만 전달할 분 **데이터가 무엇인지, 어떤 오류가 있는지 신경쓰지 않는다.**

   * 통신케이블, 리피터, 허브 등이 포함된다. 
2. 데이터 링크 계층 : 2계층
   * 물리계층을 통해 송수신되는 정보의 오류와 흐름을 관리하고 도와주는 역할을 수행한다. 
   * 따라서 **오류 검출, 재전송** 등의 기능을 가지고 있다. 
   * 이 계층에서는 **맥 주소를 가지고 통신**한다. 
   * 브릿지, 스위치(mac 주소 테이블을 이용해 해당 프레임 전송)를 통해 물리 계층에서 받은 정보를 전달한다.
   * 데이터 링크 계층은 포인트 투 포인트간 신뢰성 있는 전송을 보장하기 위해 오류 제어와 흐름제어를 한다.
     * 흐름제어는 3가지 : randomness , controlled, channelized
3. 네트워크 계층(datagram) : 3계층 
   * 데이터를 목적지까지 안전하고 빠르게 전달하는 **라우팅 기능**을 수행한다.
   * 이 계층은 이동할 경로를 선택하여 경로에 따라 패킷을 전송한다.
     * 대표적인 장비는 라우터이고, 요즘은 2계층 장비 중 스위치에 라우팅기능을 장착한 layer 3 스위치도 있다.
   * 전송 계층이 요구하는 서비스 품질을 제공하기 위해 기능적, 절차적 수단을 제공한다. 
   * 라우팅, 흐름제어, 세그먼테이션 등을 수행합니다.
4. 전송계층 (segment) : 4계층
   - TCP, UDP 프로토콜을 통해 통신을 활성화한다.
     - 데이터가 왔다면 4계층에서 데이터를 하나로 합쳐서 5계층으로 넘긴다.
     - 상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 도와준다.
5. 세션계층 : 5계층
   * 데이터가 통신하기위해 논리적 연결을 담당합니다.
     * 하지만 4계층에서도 연결을 맺고 종료할 수 있기 때문에 어느 계층에서 통신이 끊겼는지 판단하기 한계가 있다.
     * 그러므로 세션 계층은 4 계층과 무관하게 응용프로그램 관점에서 봐야한다.
   * 세션 설정, 유지, 종료
   * 세션 계층은 응용 프로세스가 통신을 관리하기 위한 방법을 제공
     * **동시 송수신 방식(duplex), 반이중 방식(half-duplex), 전이중 방식(Full Duplex)**
     * 전이중  방식은  하나의  연결을  통하여  데이터가  동시에  양  방향으로  오고  갈  수  있는  방식
     * 반이중  방식일  경우에는  대화  관리를  위해  데이터  토큰(data token)을  사용
6. 표현 계층 : 6계층
   * 데이터 표현에 대한 독립성을 제공하고 암호화하는 역할을 담당한다
   * 파일 인코딩, 명령어 포장, 압축 암호화 합니다.
   * 해당 데이터가 TEXT인지, 그림인지, GIF인지 JPG인지의 구분 등이 표현 계층의 몫
7. 응용계층 : 7계층
   * 응용 프로세스와 관계하여 응용 서비스를 수행합니다.
   * 최종 목적지로서 HTTP, FTP, SMTP, POP3, IMAP, Telnet 등과 같은 프로토콜

[OSI 7 계층이란?, OSI 7 계층을 나눈 이유 :: effortDev (tistory.com)](https://shlee0882.tistory.com/110)

 

> 추가로 찾아보기 
>
> * TCP / IP 전송방식? 
> * *<TCP, UDP 포트의 역할> : 찾아보겠습니다. 해당 포트를 보고 해당 포트의 프로세스 연결시켜줌.*!!



# TCP 3 way handshake & 4 way handshake



- 3-way handshaking를 통해 연결지향적이고, 신뢰성 있는 데이터 전송이 가능합니다.
  - **서버** : socket() 생성 → bind() 소켓 특정포트 연결 → listen() 연결요청 대기상태 → accept() 연결허용 → read/write() 데이터 송수신 → close() 연결종료
  - **클라이언트** : socket() 생성 → connect() 연결요청 → read/write() 데이터 송수신 → close() 연결종료
- 3-way handshaking
  1. client -> server : SYN
  2. server -> client : ACK+SYN
  3. client -> server : ACK
- 4-way handshaking 
  1. client → server : Fin
  2. server → client : ack + 모든 데이터 전송 완료 후 fin
  3. client → server : ack을 보내고 time wait를 통해 기다린다.
  4. server는 ack을 받고 서버를 닫는다.



> 
>
> 4 way hand 의 역할
>
> SYN은 '동시에 발생하다의 약자로, 다른 컴퓨터로 전송 된 TCP 패킷으로 연결이 이루어 지도록 요청합니다. 발생시키는 의미! -> 추가로  
>
> * 헤더에 flag 값을 통해서 어떤 패킷인지 알 수 있다. !!!



# TCP/IP 흐름제어 & 혼잡제어

> TCP/IP 

* IP 주소 체계를 따르며 TCP 특성을 활용해 송신자와 수신자의 논리적 연결을 생성하고 신뢰성을 유지할 수 있도록 하겠다는 의미



> IP 계층

* 네트워크의 주소(IP 주소)를 정의하고, **IP 패킷의 전달과 라우팅을 담당**하는 계층
* IP계층은 네트워크 계층에 해당
* IP 계층은 데이터 링크 계층의 하드웨어적 특성에 관계없이 독립적인 역할을 수행
  * IP 계층 상의 주요 프로토콜
    * 패킷의 전달을 책임지는 IP
    * 패킷 전달 에러의 보고 및 진단을 위한 ICMP
    * 복잡한 네트워크에서 인터네트워킹을 위한 경로를 찾게해주는 라우팅 프로토콜 



> IP 프로토콜

* IP 프로토콜은 신뢰성(에러제어)와 흐름제어 기능이 없다.
* 그래서 신뢰성을 확보하기 위해서는 IP 계층 위의 TCP같은 전송 계층에 의존해야한다.
* 비연결적이고, 비신뢰적이다.



> TCP 프로토콜

* 전송계층에 해당하고
* 신뢰적인 전송을 보장함으로써, 어플리케이션 구현이 한층 쉬워진다.
* 패킷 손실, 중복, 순서 바뀜 등을 보장하고 IP 계층의 신뢰성 없는 서비스에 대해 신뢰성을 제공한다.
* TCP는 연결지향적이다.



> 전송 과정

- Application layer : sender application layer가 socket에 data를 씀.
- Transport layer : data를 segment에 감싼다. 그리고 network layer에 넘겨줌.
- 그러면 아랫단에서 어쨋든 receiving node로 전송이 됨. 이 때, sender의 send buffer에 data를 저장하고, receiver는 receive buffer에 data를 저장함.
- application에서 준비가 되면 이 buffer에 있는 것을 읽기 시작함.
- 따라서 flow control의 핵심은 이 receiver buffer가 넘치지 않게 하는 것임.
-  receiver는 RWND(Receive WiNDow) : receive buffer의 남은 공간을 알립니다.



> 흐름제어

* 흐름제어 : 송신 측과 수신 측의 데이터 처리 속도 차이를 조절
* Stop and Wait와 Sliding Window 기법이 있다.
* Stop and Wait는 매번 전송 패킷에 대한 확인 응답을 받아야 다음 패킷을 전송할 수 있기 때문에 비효율적이다.
* Sliding Window는 데이터의 흐름을 동적으로 조절할 수 있다.
  * TCP/IP를 사용하는 모든 호스트들은 송신하기 위한 것과 수신하기 위한 2개의 Window을 가지고 있다.
  * 수신자는 TCP 헤더 내에 Window size를 사용해 한번에 받고 보낼 수 있는 데이터 양을 결정한다. 이것은 3-way handshake에 정한다. 후에 window size 를 조절한다.
  * 가장 왼쪽의 데이터를 받았다면 ACK 프레임만큼 오른쪽으로 경계를 이동한다. 



* TCP 윈도우를 이야기 하기 위해서는 세가지의 변수를 알아야한다.
* 수신 윈도우, 혼잡 윈도우(혼잡제어와 관련), 송신 윈도우
* 송신윈도우는 수신윈도우와 혼잡윈도우 중 작은 것으로 결정한다.
* 송신 윈도우의 크기가 클수록 많은 데이터를 보낼 수 있다.



* 네이글 알고리즘은 다음과 같다.
  1. 전송하기 위한 새로운 데이터가 있으면
     1. **MSS** 보다 송신 윈도우 사이즈가 같거나 크고 & 이용할 수 있는 데이터가 **MSS** 보다 같거나 큰 경우 **MSS** 만큼 세그먼트를 보낸다.
     2. 그렇지 않다면, 파이프에 여전히 확인 되지 않은 데이터가 있으면
        1.  확인 응답을 받을 때 까지 데이터를 버퍼에 더한다.
        2. 확인 되었으면 즉시 보낸다.

* 네이글 알고리즘은 네트워크망의 혼잡을 피하기 위해 설계되었다.

* 만약에 송신측 프로세스에서 송신 버퍼로 작은 데이터 단위로만 계속 밀어(PUSH)낸다고 한다면, 패킷당 IP 헤더와 TCP 헤더에 의해 (IPv4기준 40 bytes, 옵션) 오버헤드 비율이 더 커지게 된다.

  * 예시로 송신측이 수신측으로 90 bytes를 보내되 송신 버퍼가 크게 상관없이 데이터가 채워지자 마자 전송한다고 가정한다.

    그리고 프로세스는 세 번에 걸쳐서 데이터를 송신 버퍼로 밀어낸다고 가정한다.

     

    헤더(40bytes) + 데이터(10 bytes),

    헤더(40bytes) + 데이터 (20 bytes),

    헤더(40bytes) + 데이터 (60 bytes)

     

    데이터 90 bytes를 보내기 위해 헤더 120 bytes의 헤더를 보내야 하는 상황이 발생한다. -> 윈도우 신드롬이라고 합니다.

    즉 네트워크망을 비효율적으로 사용하는 것이다.

    실제로 총 전송된 패킷 210 bytes 중 헤더 비율이 약 57%이다.
    
    

* 단점 
  * 이전에 보낸 응답을 기다려야 한다.
  * 네이글 알고리즘이 지연 응답 방식과 비교하여 round trip 횟수가 증가 한다.
  * 기다리는 것은 MSS 만큼 데이터가 채워질 때까지 혹은 타이머에 의해 timeout 될 때까지 패킷이 전송되지 않음을 의미한다.



> 혼잡제어

혼잡제어 : 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지

한 라우터에 데이터가 몰릴 경우, 자신에게 온 데이터를 모두 처리할 수 없게 된다. 이 경우 호스트들은 또 다시 재전송을 하게되고 결국 혼잡을 가중시켜 오버플로우나 데이터 손실을 발생시킨다. 그래서 네트워크내 패킷수를 방지하는 것이 혼잡제어라고 한다.



AIMD(Additive Increase / Multiplicative Decrease)

- 처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 window 크기(단위 시간 내에 보내는 패킷의 수)를 1씩 증가시켜가며 전송하는 방법
- 패킷 전송에 실패하거나 일정 시간을 넘으면 패킷의 보내는 속도를 절반으로 줄인다.
- 공평한 방식으로, 여러 호스트가 한 네트워크를 공유하고 있으면 나중에 진입하는 쪽이 처음에는 불리하지만, 시간이 흐르면 평형상태로 수렴하게 되는 특징이 있다.
- 문제점은 초기에 네트워크의 높은 대역폭을 사용하지 못하여 오랜 시간이 걸리게 되고, 네트워크가 혼잡해지는 상황을 미리 감지하지 못한다. 즉, 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식이다.



Slow Start (느린 시작)

* AIMD가 전송 속도를 올리는데 시간이 오래 걸리는 단점이 존재
* slow start : 한 세그먼트가 ack받으면 1MSS 증가한다. 즉, 지수적으로 증가한다. 혼잡이 발생하면 1부터 다시 시작하며 혼잡 발생 시점의 절반은 SSThresh 으로 지정한다. 그리고 다시 slow start를 시작하고 SSThresh 도달하면 congestion avoidance phase 로 RTT마다 1 MSS씩 증가합니다.

- fast retransmission :  타임아웃으로 loss를 기다리는 것이 아니라, 3번의 duplicate ack으로 loss를 판단하여 재전송한다.

- fast recovery : 3번의 duplicate ack이 오면 loss로 판단하여 반으로 줄이고, congestion avoidance phase부터 시작한다.

  		* 	slow start + congestion avoidance + fast retransmission = TCP Tahoe

  		* 	TCP Tahoe + Fast Recovery -> TCP reno

  

https://gyoogle.dev/blog/computer-science/network/%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4%20&%20%ED%98%BC%EC%9E%A1%EC%A0%9C%EC%96%B4.html

https://roka88.dev/114



# UDP

* 전송 계층 중 하나로 TCP에 비해 신뢰성이 낮은 프로토콜이다. 
* 비연결적이고 신뢰성이 없으며, 순서화 되지 않은 datagram 서비스를 제공한다. 
* 하지만 빠른 요청과 응답이 필요한 실시간 응용에 적합하고 여러 다수 지점에 전송이 가능하다.
* 또한 헤더가 단순하고 작아(8바이트) 헤더 처리에 많은 시간을 요하지 않는다.



### # DNS(domain name service)에서 UDP를 사용하는 이유

- request 양이 적다 → UDP request에 담길 수 있다.
  - UDP segment에 들어갈 수 있음.
- 3 way handshking으로 연결을 유지할 필요가 없다 → connection을 유지할 필요 x
- request에 대한 손실은 application layer에서 제어가 가능하다.
  - DNS는 application layer이고, 모든 application layer는 TCP, UDP 중 하나의 transport layer를 사용해야한다.
- 연결 상태가 없기 때문에 더 많은 클라이언트를 수용할 수 있다.
- DNS : port 53
- TCP 사용하는 이유
  - Zone transfer : DNS 서버간의 요청을 주고 받을 때의 transfer
  - 데이터가 512 바이트를 넘어가거나 응답을 못받은 경우



[신뢰적인 TCP보다 비신뢰적인 UDP를 사용하는 이유 (tistory.com)](https://rain-bow.tistory.com/entry/신뢰적인-TCP보다-비신뢰적인-UDP를-사용하는-이유)